%% LyX 2.1.4 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass{article}
\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{url}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{
 pdfstartview={XYZ null null 1}}
\begin{document}
<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path='figure/', fig.align='center', fig.show='hold')
options(formatR.arrow=TRUE,width=90)
@


\title{Boolean Nested Effects Modesl\\
	Inferring the logical signalling of pathways from indirect measurements and perturbation biology}


\author{Martin Pirkl}

\maketitle
Boolean Nested effects Models (B-NEM) are used to infer signalling pathways. In different experiments (conditions) members of a pathway (S-genes) are stimulated or inhibited, alone and in combination. In each experiment transcriptional targets (E-genes) of the pathway react differently and are higher or lower expressed depending on the condition. From these differential expression B-NEM infers Boolean functions presented as hyper-edges of a hyper-graph connecting parents and children in the pathway. For example if the signal is transducted by two parents A and B to a child C and the signal can be blocked with a knock-down of either one, they are connected by a typical AND-gate. If the signal is still transduced during a single knock-down, but blocked by the double knock-down of A and B, they activate C by an OR-gate. In general the state of child C is defined by a Boolean function
\[f: \left\{0,1\right\}^n \to \left\{0,1\right\},~C = f(A_1,\dots,A_n)\]
 with its parents $A_i$.

\section*{Loading B-NEM}

<<installandload>>=
X11.options(type="Xlib")

## install.packages("bnem_1.0.tar.gz")

install.packages("devtools")

library(devtools)

dev_mode(on=T)

install_github("MartinFXP/bnem/package")

dev_mode(on=F)

library(bnem)
@

\section*{A simple toy example}
We show how to use B-NEM on a toy example. B-NEM demands several objects as input. The two main objects are the differential gene expression (data) and prior knowledge.

First we create a prior knowledge network (PKN). The PKN will have two S-genes without parents. We define these as stimuli, which means they are set to $1$ in experiments, where they are stimulated and $0$ otherwise. All other down-stream S-genes have the potential to be inhibited $(0)$. If they are not inhibited their state is calculated according to their parents' state and the Boolean function.

<<createpkn>>=
set.seed(2579)
## alternative seed and also a great song:
## set.seed(9247)

## to get the while loop started which makes sure we get a PKN with exactly two stimuli (not necessary):
stimuli <- "dummy"

while(length(stimuli) != 2) {

## random Boolean graph without cycles, maximal 25 edges, maximal edge size of 1 (normal graph) and maximal 10 S-genes:
  dnf <- randomDnf(10, max.edges = 25, max.edge.size = 1, dag = T) 
  
## all S-genes:
  cues <- sort(unique(gsub("!", "", unlist(strsplit(unlist(strsplit(dnf, "=")), "\\+")))))

## parents:
  inputs <- unique(unlist(strsplit(gsub("!", "", gsub("=.*", "", dnf)), "=")))

## children:
  outputs <- unique(gsub(".*=", "", dnf))

## parents which are no children are stimuli:
  stimuli <- inputs[which(!(inputs %in% outputs))]

}

inhibitors <- unique(c(inputs, outputs))
## S-genes which are no stimuli are inhibitors
inhibitors <- inhibitors[-which(inhibitors %in% stimuli)]
@
The following figure shows the PKN. Red "tee" arrows depict repression the others activation of the child. The stimulated S-genes are diamond shaped.
<<plotpkn, fig.width=4, fig.height=4, out.width='0.4\\linewidth'>>=
plotDnf(dnf, stimuli = stimuli)
@
In the next step we convert the dnf object into a PKN and extend it to a Boolean hyper-graph, which includes all functions allowed by the PKN.
<<pknextend>>=
sifMatrix <- NULL

for (i in dnf) {
  inputs2 <- unique(unlist(strsplit(gsub("=.*", "", i), "=")))
  output <- unique(gsub(".*=", "", i))
  for (j in inputs2) {
    j2 <- gsub("!", "", j)
    if (j %in% j2) {
      sifMatrix <- rbind(sifMatrix, c(j, 1, output))
    } else {
      sifMatrix <- rbind(sifMatrix, c(j2, -1, output))
    }
  }
}
write.table(sifMatrix, file = "temp.sif", sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
PKN <- readSIF("temp.sif")
## unlink("temp.sif")

## create dummy metainformation:
CNOlist <- dummyCNOlist(stimuli = stimuli, inhibitors = inhibitors, maxStim = 2, maxInhibit = 1, signals = NULL)

## extend the model:
model <- preprocessing(CNOlist, PKN, maxInputsPerGate=100) 
@
We suggest to take a look at the sif file. In future analyses it is easier to just provide a suitable sif file for the investigated pathway.

In a real world application the underlaying real ground truth network (GTN) is not known. However in our toy example we define one.
<<definegtn>>=
## define a bitstring denoting the present and absent edges:
bString <- absorption(sample(c(0,1), length(model$reacID), replace = T), model)

## simulate S-gene states for all possible conditions:
steadyState <- steadyState2 <- simulateStatesRecursive(CNOlist, model, bString)

## we find constitutively active S-genes with the folloing:
steadyState2[, grep(paste(inhibitors, collapse = "|"), colnames(steadyState2))] <- steadyState2[, grep(paste(inhibitors, collapse = "|"), colnames(steadyState2))] + CNOlist@inhibitors

## this while loop makes sure we get a gtn which actually affects all vertices and no vertices are constitutively active (not necessary):
while(any(apply(steadyState, 2, sd) == 0) | any(apply(steadyState2, 2, sd) == 0)) {

  bString <- absorption(sample(c(0,1), length(model$reacID), replace = T), model)

  steadyState <- steadyState2 <- simulateStatesRecursive(CNOlist, model, bString)

  steadyState2[, grep(paste(inhibitors, collapse = "|"), colnames(steadyState2))] <- steadyState2[, grep(paste(inhibitors, collapse = "|"), colnames(steadyState2))] + CNOlist@inhibitors

}
@
The following figure shows our random GTN, which is a subset of the complete search space (model based on the PKN).
<<plotgtn, fig.width=4, fig.height=4, out.width='0.4\\linewidth'>>=
plotDnf(model$reacID[as.logical(bString)], stimuli = stimuli)
@
We now use this GTN to simulate data.
<<datasim>>=
## this objects holds all data:
NEMlist <- list() 

## the expression data with 10 E-genes for each S-gene and 3 replicates (not used):
NEMlist$exprs <- t(steadyState)[rep(1:ncol(steadyState), 10), rep(1:nrow(steadyState), 3)]

## we calculate the foldchanges or expected S-gene response scheme (ERS) between certain condtion (e.g. control vs stimulation):
ERS <- computeFc(CNOlist, t(steadyState))

# the next step reduces the ERS to a sensible set of comparisons; e.g. we do not want to compare stimuli vs inhibition, but stimuli vs (stimuli,inhibition):
stimuli.pairs <- apply(apply(expand.grid(stimuli, stimuli), c(1,2), as.character), 1, paste, collapse = "_")

## this is the usual setup, but "computeFc" calculates a lot more contrasts, which can also be used if preferred:
ERS <- ERS[, grep(paste(c(paste("Ctrl_vs_", c(stimuli, inhibitors), sep = ""), paste(stimuli, "_vs_", stimuli, "_", rep(inhibitors, each = length(stimuli)), sep = ""), paste(stimuli.pairs, "_vs_", stimuli.pairs, "_", rep(inhibitors, each = length(stimuli.pairs)), sep = "")), collapse = "|"), colnames(ERS))]

## same as before with the expression values, we have 10 E-genes each and 3 replicates:
NEMlist$fc <- ERS[rep(1:nrow(ERS), 10), rep(1:ncol(ERS), 3)]

## we add some Gaussian noise:
NEMlist$fc <- NEMlist$fc + rnorm(length(NEMlist$fc), 0, 1)

## some E-genes are negative regulated, hence we flip their foldchanges:
flip <- sample(1:nrow(NEMlist$fc), floor(0.33*row(NEMlist$fc)))
NEMlist$fc[flip, ] <- NEMlist$fc[flip, ]*(-1)

rownames(NEMlist$fc) <- paste(rownames(NEMlist$fc), 1:nrow(NEMlist$fc), sep = "_")
print(NEMlist$fc[1:6, c(1:3,(ncol(NEMlist$fc)-2):ncol(NEMlist$fc))])
@
B-NEM uses differential expression between experiments to infer the pathway logics. For example look at the colnames of NEMlist\$fc (=foldchanges of E-genes (rows)) and remember that \Sexpr{stimuli} are our stimulated S-genes and the rest possibly inhibited. Thus in the first column of NEMlist\$fc we have the contrast \Sexpr{gsub(".*_", "", colnames(NEMlist$fc)[1])} $-$ control. In the control no S-genes are perturbed.

We search for the GTN in our restricted network space. Each network is a sub-graph of the full hyper-graph model\$reacID. We initialise the search with a starting network and greedily search the neighbourhood.

<<localsearch>>=
## start with empty graph:
initBstring <- reduceGraph(rep(0, length(model$reacID)), model, CNOlist)
## initBstring <- reduceGraph(rep(1, length(model$reacID)), model, CNOlist)

## paralellize for several threads on one machine or multiple machines. See package "snowfall" for details.
parallel <- 2 # list(c(4,16,8,2), c("machine1", "machine2", "machine3", "machine4"))

## greedy search:
greedy <- bnem(search = "greedy",
            CNOlist=CNOlist,
            NEMlist=NEMlist,
            model=model,
            parallel=parallel,
            initBstring=initBstring,
            draw = FALSE,
            verbose = FALSE,
            maxSteps = Inf
            )

resString <- greedy$bString
@
We can now take a look at the efficiency of the search algorithm with sensitivity and specificity of the optimal found network and the accuracy of its ERS (similar to the truth table). Since several network produce the same ERS, the found hyper-graph can differ from the GTN and still be $100\%$ accurate.
<<plotresult, fig.width=4, fig.height=4, out.width='0.4\\linewidth'>>=
par(mfrow=c(1,2))

## GTN:
plotDnf(model$reacID[as.logical(bString)], main = "GTN", stimuli = stimuli)

## optimum found:
plotDnf(model$reacID[as.logical(resString)], main = "greedy optimum", stimuli = stimuli)
@
<<accuracy>>=
## hyper-edge sensitivity and specificity:
print(sum(bString == 1 & resString == 1)/(sum(bString == 1 & resString == 1) + sum(bString == 1 & resString == 0)))
print(sum(bString == 0 & resString == 0)/(sum(bString == 0 & resString == 0) + sum(bString == 0 & resString == 1)))

## accuracy of expected response scheme from learned network should be high even though the network can look different:
ERS.res <- computeFc(CNOlist, t(simulateStatesRecursive(CNOlist, model, resString)))
ERS.res <- ERS.res[, which(colnames(ERS.res) %in% colnames(ERS))]
print(sum(ERS.res == ERS)/length(ERS))
@
In our seeded example 2574 the optimum network is indeed the GTN. If you set the alternative seed at the beginning, neither the network nor the correct ERS is found with the empty network at the start. If you start with the PKN, the ERS is resolved completely while the network is still not the GTN. Thus the GTN and the optimum are equivalent, but the GTN is larger and thus not preferred.

After optimization you can look at the data and how well your networks explains the E-genes. The lower the score the better the fit.

<<visualfit, fig.width=20, fig.height=10, out.width='1.0\\linewidth'>>=
fitinfo <- validateGraph(CNOlist, NEMlist, model = model, bString = resString, Sgene = 1, Egenes = 1000, cexRow = 0.8, cexCol = 0.7, xrot = 45, disc = 0, Colv = T, Rowv = T, dendrogram = "both", bordercol = "lightgrey", aspect = "iso", sub = "")
@ 

The bottom row shows the ERS of S-gene \Sexpr{colnames(CNOlist@signals[[1]])[1]} and the other rows show the observed response scheme (ORS) of the \Sexpr{colnames(CNOlist@signals[[1]])[1]}-regulated E-genes. Even though the Gaussian noise makes the data look almost random, we still found the GTN.
Alternatively to the greedy neightbourhood search a genetic algorithm and exhaustive search are also available. The exhaustive search is not recommended for search spaces with more than 20 hyper-edges.


<<ga>>=
## genetic algorithm:
genetic <- bnem(search = "genetic",
           parallel = parallel,
           CNOlist=CNOlist,
           NEMlist = NEMlist,
           model=model,
           initBstring=initBstring,
           popSize = 10,
           stallGenMax = 10,
           graph = FALSE,
           verbose = FALSE
           )

resString <- genetic$bString
@
<<exhaustive>>=
## ## exhaustive search:
## exhaustive <- bnem(search = "exhaustive",
##            parallel = parallel,
##            CNOlist=CNOlist,
##            NEMlist = NEMlist,
##            model=model
##            )

## resString <- exRun$bString
@

\section*{Stimulated and inhibited S-genes can overlap}
In this section we show how to use B-NEM when stimuli and inhibitors overlap. For this we allow the PKN to have cycles, but no repression, because repression can lead to an unresolvable ERS. See Pirkl et al., 2016 for details.

<<createpkn2>>=
## we do not force a DAG but do not allow repression:
dnf <- randomDnf(10, max.edges = 25, max.edge.size = 1, dag = F, negation = F) 
cues <- sort(unique(gsub("!", "", unlist(strsplit(unlist(strsplit(dnf, "=")), "\\+")))))
inputs <- unique(unlist(strsplit(gsub("!", "", gsub("=.*", "", dnf)), "=")))
outputs <- unique(gsub(".*=", "", dnf))
stimuli <- c(inputs[which(!(inputs %in% outputs))], cues[sample(1:length(cues), 2)])
inhibitors <- cues
@

Now we look for stimuli which are also inhibited. For those we add additional stimuli S-genes. The stimuli S-gene (parent) and the inhibitor S-gene (child) are connected by a positive edge.

<<addstimuli>>=
both <- stimuli[which(stimuli %in% inhibitors)]
for (i in both) {
  dnf <- gsub(i, paste(i, "inhibit", sep = ""), dnf)
  dnf <- c(dnf, paste(i, "stim=", i, "inhibit", sep = ""))
  stimuli <- gsub(i, paste(i, "stim", sep = ""), stimuli)
  inhibitors  <- gsub(i, paste(i, "inhibit", sep = ""), inhibitors)
}
@

The next figure shows the cyclic PKN with extra stimuli S-genes. Notice, this way the inhibition of the S-genes overrules the stimulation.

<<plotpkn2, fig.width=6, fig.height=6, out.width='0.6\\linewidth'>>=
plotDnf(dnf, stimuli = stimuli)
@

Similar to before we create the full network search space, draw a GTN, simulate data and search for the optimal network.

<<pknextend2>>=
sifMatrix <- NULL
for (i in dnf) {
  inputs2 <- unique(unlist(strsplit(gsub("=.*", "", i), "=")))
  output <- unique(gsub(".*=", "", i))
  for (j in inputs2) {
    j2 <- gsub("!", "", j)
    if (j %in% j2) {
      sifMatrix <- rbind(sifMatrix, c(j, 1, output))
    } else {
      sifMatrix <- rbind(sifMatrix, c(j2, -1, output))
    }
  }
}
write.table(sifMatrix, file = "temp.sif", sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
PKN <- readSIF("temp.sif")
## unlink("temp.sif")
CNOlist <- dummyCNOlist(stimuli = stimuli, inhibitors = inhibitors, maxStim = 2, maxInhibit = 1, signals = NULL)
model <- preprocessing(CNOlist, PKN, maxInputsPerGate=100) 
@
<<definegtn2>>=
bString <- absorption(sample(c(0,1), length(model$reacID), replace = T), model)
steadyState <- steadyState2 <- simulateStatesRecursive(CNOlist, model, bString)
steadyState2[, grep(paste(inhibitors, collapse = "|"), colnames(steadyState2))] <- steadyState2[, grep(paste(inhibitors, collapse = "|"), colnames(steadyState2))] + CNOlist@inhibitors
while(any(apply(steadyState, 2, sd) == 0) | any(apply(steadyState2, 2, sd) == 0)) {
  bString <- absorption(sample(c(0,1), length(model$reacID), replace = T), model)
  steadyState <- steadyState2 <- simulateStatesRecursive(CNOlist, model, bString)
  steadyState2[, grep(paste(inhibitors, collapse = "|"), colnames(steadyState2))] <- steadyState2[, grep(paste(inhibitors, collapse = "|"), colnames(steadyState2))] + CNOlist@inhibitors
}
## we make sure the stimulations work:
bString[grep("stim", model$reacID)] <- 1
bString <- absorption(bString,model)
@
<<plotgtn2, fig.width=7, fig.height=6, out.width='0.6\\linewidth'>>=
plotDnf(model$reacID[as.logical(bString)], stimuli = stimuli)
@
<<datasim2>>=
NEMlist <- list() 
NEMlist$exprs <- t(steadyState)[rep(1:ncol(steadyState), 10), rep(1:nrow(steadyState), 3)]
ERS <- computeFc(CNOlist, t(steadyState))
stimuli.pairs <- apply(apply(expand.grid(stimuli, stimuli), c(1,2), as.character), 1, paste, collapse = "_")
ERS <- ERS[, grep(paste(c(paste("Ctrl_vs_", c(stimuli, inhibitors), sep = ""), paste(stimuli, "_vs_", stimuli, "_", rep(inhibitors, each = length(stimuli)), sep = ""), paste(stimuli.pairs, "_vs_", stimuli.pairs, "_", rep(inhibitors, each = length(stimuli.pairs)), sep = "")), collapse = "|"), colnames(ERS))]
NEMlist$fc <- ERS[rep(1:nrow(ERS), 10), rep(1:ncol(ERS), 3)]
NEMlist$fc <- NEMlist$fc + rnorm(length(NEMlist$fc), 0, 1)
flip <- sample(1:nrow(NEMlist$fc), floor(0.33*row(NEMlist$fc)))
NEMlist$fc[flip, ] <- NEMlist$fc[flip, ]*(-1)
rownames(NEMlist$fc) <- paste(rownames(NEMlist$fc), 1:nrow(NEMlist$fc), sep = "_")
print(NEMlist$fc[1:6, c(1:3,(ncol(NEMlist$fc)-2):ncol(NEMlist$fc))])
@
<<localsearch2>>=
initBstring <- reduceGraph(rep(0, length(model$reacID)), model, CNOlist)
greedy2 <- bnem(search = "greedy",
            CNOlist=CNOlist,
            NEMlist=NEMlist,
            model=model,
            parallel=parallel,
            initBstring=initBstring,
            draw = FALSE,
            verbose = FALSE,
            maxSteps = Inf
            )
resString2 <- greedy2$bString
@
<<plotresult2, fig.width=7, fig.height=6, out.width='0.6\\linewidth'>>=
par(mfrow=c(1,2))
plotDnf(model$reacID[as.logical(bString)], main = "GTN", stimuli = stimuli)
plotDnf(model$reacID[as.logical(resString2)], main = "greedy optimum", stimuli = stimuli)
@
<<accuracy2>>=
print(sum(bString == 1 & resString2 == 1)/(sum(bString == 1 & resString2 == 1) + sum(bString == 1 & resString2 == 0)))
print(sum(bString == 0 & resString2 == 0)/(sum(bString == 0 & resString2 == 0) + sum(bString == 0 & resString2 == 1)))
ERS.res <- computeFc(CNOlist, t(simulateStatesRecursive(CNOlist, model, resString2)))
ERS.res <- ERS.res[, which(colnames(ERS.res) %in% colnames(ERS))]
print(sum(ERS.res == ERS)/length(ERS))
@ 
The optimal network looks very different and has lower sensitivity and specificity. However the accuracy of the ERS is still $100\%$.
<<sessioninfo>>=
sessionInfo()
@

Pirkl, Martin, Hand, Elisabeth, Kube, Dieter, \& Spang, Rainer. 2016. Analyzing synergistic and non-synergistic interactions in signalling pathways using Boolean Nested Effect Models. \textit{Bioinformatics}, 32(6), 893–900.

\end{document}
